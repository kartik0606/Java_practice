//import java.util.HashMap;
//
//public class Main {
//    public static void main(String[] args) {
//
//
//        String s = "ADOBECODEBANC";
//        String t = "ABC";
//        System.out.println(miniwindow(s,t));
//    }
//
//    static String miniwindow(String s, String t) {
//        HashMap<Character, Integer> map = new HashMap<>();
//        for (int i = 0; i < t.length(); i++) {
//            char c = t.charAt(i);
//            map.put(c, map.getOrDefault(c, 0) + 1);
//
//        }
//        int left = 0;
//        int right = 0;
//        int count = map.size();
//        int mini = Integer.MAX_VALUE;
//        int start = 0;
//
//        while (right < s.length()) {
//            char c = s.charAt(right);
//            if (map.containsKey(c)) {
//                map.put(c, map.get(c) - 1);
//                if (map.get(c) == 0) {
//                    count--;
//                }
//            }
//            while (count == 0) {
//                if (right - left + 1 < mini) {
//                    mini = right - left + 1;
//                    start = left;
//                }
//                char leftchar = s.charAt(left);
//                if (map.containsKey(leftchar)) {
//                    map.put(leftchar, map.get(leftchar) + 1);
//                    if (map.get(leftchar) > 0) {
//                        count++;
//                    }
//                }
//                left++;
//
//            }
//            right++;
//        }
//        if (mini==Integer.MAX_VALUE){
//            return " ";
//        }else {
//            return s.substring(start,start+mini);
//        }
//    }
//}

//
//import java.util.HashMap;
//
//public class Main {
//    public static void main(String[] args) {
//         String s = "ADOBECODEBANC";
//         String t = "ABC";
//        System.out.println(miniwindow(s,t));
//
//    }
//
//    static String miniwindow(String s, String t) {
//        HashMap<Character, Integer> map = new HashMap<>();
//        for (int i = 0; i < t.length(); i++) {
//            char c = t.charAt(i);
//            map.put(c, map.getOrDefault(c, 0) + 1);
//
//
//        }
//        int left = 0;
//        int right = 0;
//        int count = map.size();
//        int start = left;
//        int mini = Integer.MAX_VALUE;
//        while (right < s.length()) {
//            char c = s.charAt(right);
//            if (map.containsKey(c)) {
//                map.put(c, map.get(c) - 1);
//                if (map.get(c) == 0) {
//                    count--;
//                }
//
//            }
//            while (count == 0) {
//                if (right - left + 1 < mini) {
//                    mini = right - left + 1;
//                    start = left;
//                }
//                char charleft = s.charAt(left);
//                if (map.containsKey(charleft)) {
//                    map.put(charleft, map.get(charleft) + 1);
//                    if (map.get(charleft) > 0) {
//                        count++;
//                    }
//
//                }
//               left++;
//            }
//            right++;
//
//        }
//        if (mini == Integer.MAX_VALUE) {
//            return " ";
//        } else {
//            return s.substring(start, start + mini);
//        }
//
//    }
//}
//Easy Sliding Window Array Problems
//1. Maximum Sum Subarray of Size K (Fixed-Size Sliding Window)
//Given an integer array and a number k, find the contiguous subarray of length k that has the largest sum. In other words, slide a fixed-size window of length k across the array and compute the sum of elements in each window, then return the maximum sum foundgeeksforgeeks.org. This is a classic fixed-window sliding window problem that can be solved in linear time by updating the running window sum as the window moves.
//* Type: Fixed-size window
//* Input: An array of integers arr[] and an integer k.
//* Output: A single integer representing the maximum sum of any contiguous subarray of size k.

import java.util.Arrays;
import java.util.HashMap;

//public class Main {
//    public static void main(String[] args) {
//         int[]arr = { 1,2,3,4,5,6};
//         int k = 3;
//        System.out.println(maxsum(arr,k));
//
//    }
//
//    static int maxsum(int[] arr, int k) {
//        int left = 0;
//        int right = 0;
//        int sum = 0;
//        int max = Integer.MIN_VALUE;
//        while (right < k) {
//            sum = sum + arr[right];
//            right++;
//        }
//        max = sum;
//         while (right<arr.length){
//              sum =  sum + arr[right];
//              sum = sum - arr[left];
//              left++;
//              right++;
//
//              max = Math.max(max,sum);
//
//             }
//          return max;
//
//
//
//        }
//
//    }



// public class Main {
//     public static void main(String[] args) {
//          int[]arr = { 1,2,3,4,5,6};
//          int k = 3 ;
//         System.out.println(maxsum(arr,k));
//
//     }
//
//     static  int maxsum(int[]arr , int k ){
//          int left = 0 ;
//          int right  = 0 ;
//          int sum = 0 ;
//          int max  = Integer.MIN_VALUE;
//           while (right<k){
//                sum = sum + arr[right];
//                right++;
//
//               }
//            max = sum;
//            while ( right<arr.length){
//                 sum  = sum + arr[right];
//                 sum = sum - arr[left];
//                  left++;
//                   right++;
//
//                   max = Math.max(max,sum);
//           }
//             return  max;
//     }
//}
//3. First Negative Integer in Every Window of Size K (Fixed-Size Sliding Window)
//Given an array of integers (which may include negatives) and a positive integer k, find the first negative number in each contiguous subarray of size k. If a window does not contain any negative number, report 0 for that windowgeeksforgeeks.org. For example, with arr = [-8, 2, 3, -6, 1] and k = 2, the windows are [-8,2], [2,3], [3,-6], [-6,1] and the first negatives are [-8, 0, -6, -6]. This can be done with a fixed-size window by maintaining a queue or index of negative values as the window slides.
//* Type: Fixed-size window
//* Input: An array of integers arr[] (may include negatives) and an integer k.
//        * Output: An array of integers
//
//of length n-k+1, where
// each
// is the first negative integer in the corresponding window (or 0 if none exists).
//
//
public class Main {
    public static void main(String[] args) {

        String s = "ADOBECODEBANC";
        String t = "ABC";
        System.out.println(mini(s,t));

    }

    static String mini(String s, String t) {
        HashMap<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < t.length(); i++) {
            char c = t.charAt(i);
            map.put(c, map.getOrDefault(c, 0) + 1);

        }
        int left = 0;
        int right = 0;
        int count = map.size();
        int mini = Integer.MAX_VALUE;
        int start = 0;
        while (right < s.length()) {
            char c = s.charAt(right);
            if (map.containsKey(c)) {
                map.put(c, map.get(c) - 1);
                if (map.get(c) == 0) {
                    count--;
                }
            }
                while (count == 0) {
                    if (right - left + 1 < mini) {
                        mini = right - left + 1;
                        start = left;
                    }
                    char leftchar = s.charAt(left);
                    if (map.containsKey(leftchar)) {
                        map.put(leftchar, map.get(leftchar) + 1);
                        if (map.get(leftchar) > 0) {
                            count++;
                        }

                    }
                    left++;
                }
                right++;

            }
            if (mini == Integer.MAX_VALUE) {
                return " ";
            } else {
                return s.substring(start, start + mini);
            }
        }
    }

